<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 5. Performance tips</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="PostGIS Manual"><link rel="up" href="index.html" title="PostGIS Manual"><link rel="previous" href="ch04.html" title="Chapter 4. Using PostGIS"><link rel="next" href="ch06.html" title="Chapter 6. PostGIS Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Performance tips</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2525866"></a>Chapter 5. Performance tips</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch05.html#id2525872">5.1. Small tables of large geometries</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#id2525878">5.1.1. Problem description</a></span></dt><dt><span class="sect2"><a href="ch05.html#id2525930">5.1.2. Workarounds</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#id2525990">5.2. CLUSTERing on geometry indices</a></span></dt><dt><span class="sect1"><a href="ch05.html#id2526046">5.3. Avoiding dimension conversion</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2525872"></a>5.1. Small tables of large geometries</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525878"></a>5.1.1. Problem description</h3></div></div><div></div></div><p>
Current PostgreSQL versions (including 8.0) suffer from a query
optimizer weakness regarding TOAST tables. TOAST tables are a kind of
"extension room" used to store large (in the sense of data size) values
that do not fit into normal data pages (like long texts, images or
complex geometries with lots of vertices), see
http://www.postgresql.org/docs/8.0/static/storage-toast.html for more
information).
</p><p>
The problem appears if you happen to have a table with rather large
geometries, but not too much rows of them (like a table containing the
boundaries of all european countries in high resolution). Then the table
itsself is small, but it uses lots of TOAST space. In our example case,
the table itsself had about 80 rows and used only 3 data pages, but the
TOAST table used 8225 pages.
</p><p>
Now issue a query where you use the geometry operator &amp;&amp; to search for a
bounding box that matches only very few of those rows. Now the query
optimizer sees that the table has only 3 pages and 80 rows. He estimates
that a sequential scan on such a small table is much faster than using
an index. And so he decides to ignore the GIST index. Usually, this
estimation is correct. But in our case, the &amp;&amp; operator has to fetch
every geometry from disk to compare the bounding boxes, thus reading all
TOAST pages, too.
</p><p>
To see whether your suffer from this bug, use the "EXPLAIN ANALYZE"
postgresql command. For more information and the technical details, you
can read the thread on the postgres performance mailing list:
http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525930"></a>5.1.2. Workarounds</h3></div></div><div></div></div><p>
The PostgreSQL people are trying to solve this issue by making the query
estimation TOAST-aware. For now, here are two workarounds:
</p><p>
The first workaround is to force the query planner to use the index.
Send "SET enable_seqscan TO off;" to the server before issuing the
query. This basically forces the query planner to avoid sequential scans
whenever possible. So it uses the GIST index as usual. But this flag has
to be set on every connection, and it causes the query planner to make
misestimations in other cases, so you should "SET enable_seqscan TO on;"
after the query.
</p><p>
The second workaround is to make the sequential scan as fast as the
query planner thinks. This can be achieved by creating an additional
column that "caches" the bbox, and matching against this. In our
example, the commands are like:
</p><pre class="programlisting">
SELECT addGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2');

UPDATE mytable set bbox = Envelope(Force_2d(the_geom));
</pre><p>
Now change your query to use the &amp;&amp; operator against bbox instead of
geom_column, like:
</p><pre class="programlisting">
SELECT geom_column FROM mytable WHERE bbox &amp;&amp; SetSrid('BOX3D(0 0,1 1)'::box3d,4326);
</pre><p>
Of yourse, if you change or add rows to mytable, you have to keep the
bbox "in sync". The most transparent way to do this would be triggers,
but you also can modify your application to keep the bbox column current
or run the UPDATE query above after every modification.
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2525990"></a>5.2. CLUSTERing on geometry indices</h2></div></div><div></div></div><p>
For tables that are mostly read-only, and where a single index is used for the
majority of queries, PostgreSQL offers the CLUSTER command. This command 
physically reorders all the data rows in the same order as the index criteria,
yielding two performance advantages: First, for index range scans, the number of 
seeks on the data table is drastically reduced. Second, if your working set
concentrates to some small intervals on the indices, you have a more efficient
caching because the data rows are spread along fewer data pages. (Feel invited
to read the CLUSTER command documentation from the PostgreSQL manual at this
point.)
</p><p>
However, currently PostgreSQL does not allow clustering on PostGIS GIST indices
because GIST indices simply ignores NULL values, you get an error message like:
</p><pre class="programlisting">
lwgeom=# CLUSTER my_geom_index ON my_table;
ERROR:  cannot cluster when index access method does not handle null values
HINT:  You may be able to work around this by marking column "the_geom" NOT NULL.
</pre><p>
As the HINT message tells you, one can work around this deficiency by adding a
"not null" constraint to the table:
</p><pre class="programlisting">
lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null;
ALTER TABLE
</pre><p>
Of course, this will not work if you in fact need NULL values in your geometry
column. Additionally, you must use the above method to add the constraint, using
a CHECK constraint like "ALTER TABLE blubb ADD CHECK (geometry is not null);" will
not work.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2526046"></a>5.3. Avoiding dimension conversion</h2></div></div><div></div></div><p>
Sometimes, you happen to have 3D or 4D data in your table, but always access
it using OpenGIS compliant asText() or asBinary() functions that only output
2D geometries. They do this by internally calling the force_2d() function,
which introduces a significant overhead for large geometries. To avoid this
overhead, it may be feasible to pre-drop those additional dimensions once and
forever:
</p><pre class="programlisting">
UPDATE mytable SET the_geom = force_2d(the_geom);
VACUUM FULL ANALYZE mytable;
</pre><p>
Note that if you added your geometry column using AddGeometryColumn()
there'll be a constraint on geometry dimension.
To bypass it you will need to drop the constraint.
Remember to update the entry in the geometry_columns table and
recreate the constraint afterwards.
</p><p>
In case of large tables, it may be wise to divide this UPDATE into smaller portions
by constraining the UPDATE to a part of the table via a WHERE clause and your
primary key or another feasible criteria, and running a simple "VACUUM;" between
your UPDATEs. This drastically reduces the need for temporary disk space.
Additionally, if you have mixed dimension geometries, restricting the UPDATE by "WHERE 
dimension(the_geom)&gt;2" skips re-writing of geometries that already are in 2D. 
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. Using PostGIS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. PostGIS Reference</td></tr></table></div></body></html>
