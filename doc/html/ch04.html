<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 4. Using PostGIS</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="PostGIS Manual"><link rel="up" href="index.html" title="PostGIS Manual"><link rel="previous" href="ch03.html" title="Chapter 3. Frequently Asked Questions"><link rel="next" href="ch05.html" title="Chapter 5. Performance tips"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Using PostGIS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2522713"></a>Chapter 4. Using PostGIS</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch04.html#RefObject">4.1. GIS Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2522740">4.1.1. OpenGIS WKB and WKT</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2522847">4.1.2. PostGIS EWKB, EWKT and Canonical Forms</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2523004">4.2. Using OpenGIS Standards</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2523037">4.2.1. The SPATIAL_REF_SYS Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2523246">4.2.2. The GEOMETRY_COLUMNS Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2523380">4.2.3. Creating a Spatial Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2523486">4.2.4. Ensuring OpenGIS compliancy of geometries</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2523576">4.3. Loading GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2523590">4.3.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2523645">4.3.2. Using the Loader</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2523875">4.4. Retrieving GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2523888">4.4.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2524054">4.4.2. Using the Dumper</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2524232">4.5. Building Indexes</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2524285">4.5.1. GiST Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2524354">4.5.2. Using Indexes</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2524472">4.6. Complex Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2524491">4.6.1. Taking Advantage of Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2524587">4.6.2. Examples of Spatial SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2524902">4.7. Using Mapserver</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2524945">4.7.1. Basic Usage</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2525193">4.7.2. Frequently Asked Questions</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2525360">4.7.3. Advanced Usage</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2453149">4.7.4. Examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id2453247">4.8. Java Clients (JDBC)</a></span></dt><dt><span class="sect1"><a href="ch04.html#id2525835">4.9. C Clients (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id2525844">4.9.1. Text Cursors</a></span></dt><dt><span class="sect2"><a href="ch04.html#id2525854">4.9.2. Binary Cursors</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. GIS Objects</h2></div></div><div></div></div><p>The GIS objects supported by PostGIS are a superset of
      the "Simple Features" defined by the OpenGIS Consortium (OGC).
      As of version 0.9, PostGIS supports all the objects and functions
      specified in the OGC "Simple Features for SQL" specification.</p><p>PostGIS extends the standard with support for 3DZ,3DM and 4D
      coordinates.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2522740"></a>4.1.1. OpenGIS WKB and WKT</h3></div></div><div></div></div><p>The OpenGIS specification defines two standard ways of
        expressing spatial objects: the Well-Known Text (WKT) form and
	the Well-Known Binary (WKB) form. Both WKT and WKB include
	information about the type of the object and the
        coordinates which form the object.</p><p>Examples of the text representations (WKT) of the spatial
      objects of the features are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>POINT(0 0)</p></li><li><p>LINESTRING(0 0,1 1,1 2)</p></li><li><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li><p>MULTIPOINT(0 0,1 2)</p></li><li><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)),
	  ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING((2 3,3 4)))</p></li></ul></div><p>The OpenGIS specification also requires that the
        internal storage format of spatial objects include a spatial
        referencing system identifier (SRID). The SRID is required when
        creating spatial objects for insertion into the database.</p><p>
Input/Output of these formats are available using the following
interfaces:
</p><pre class="programlisting">
	bytea WKB = asBinary(geometry);
	text WKT = asText(geometry);
	geometry = GeomFromWKB(bytea WKB, SRID); 
	geometry = GeometryFromText(text WKT, SRID);
	</pre><p> For example, a valid insert statement to create and insert an OGC spatial object would be:</p><pre class="programlisting">
	INSERT INTO SPATIALTABLE ( 
		  THE_GEOM, 
		  THE_NAME 
	) 
	VALUES ( 
		  GeomFromText('POINT(-126.4 45.32)', 312), 
		  'A Place' 
	)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2522847"></a>4.1.2. PostGIS EWKB, EWKT and Canonical Forms</h3></div></div><div></div></div><p>
OGC formats only support 2d geometries, and the associated SRID
is *never* embedded in the input/output representations.
</p><p>
Postgis extended formats are currently superset of OGC one (every
valid WKB/WKT is a valid EWKB/EWKT) but this might vary in the
future, specifically if OGC comes out with a new format conflicting
with our extensions. Thus you SHOULD NOT rely on this feature!
</p><p>
Postgis EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded
SRID information.
</p><p>Examples of the text representations (EWKT) of the
      extended spatial objects of the features are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>POINT(0 0 0) -- XYZ</p></li><li><p>SRID=32632;POINT(0 0) -- XY with SRID</p></li><li><p>POINTM(0 0 0) -- XYM</p></li><li><p>POINT(0 0 0 0) -- XYZM</p></li><li><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID</p></li><li><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4
          1))</p></li><li><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2
          0,1 1 0))</p></li><li><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2
          0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li><p>GEOMETRYCOLLECTIONM(POINTM(2 3 9),LINESTRINGM((2 3 4,3 4
          5)))</p></li></ul></div><p>
Input/Output of these formats are available using the following
interfaces:
</p><pre class="programlisting">
	bytea EWKB = asEWKB(geometry);
	text EWKT = asEWKT(geometry);
	geometry = GeomFromEWKB(bytea EWKB);
	geometry = GeomFromEWKT(text EWKT);
	</pre><p>
For example, a valid insert statement to create and insert a PostGIS spatial object would be:
</p><pre class="programlisting">
	INSERT INTO SPATIALTABLE ( 
		  THE_GEOM, 
		  THE_NAME 
	) 
	VALUES ( 
		  GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 
		  'A Place' 
	)</pre><p>
The "canonical forms" of a PostgreSQL type are the representations
you get with a simple query (without any function call) and the one
which is guaranteed to be accepted with a simple insert, update or
copy. For the postgis 'geometry' type these are:

	</p><pre class="programlisting">
	- Output -
	binary: EWKB
	 ascii: HEXEWKB (EWKB in hex form)

	- Input -
	binary: EWKB
	 ascii: HEXEWKB|EWKT
	</pre><p>
</p><p>
For example this statement reads EWKT and returns HEXEWKB in the
process of canonical ascii input/output:
</p><pre class="programlisting">
	=# SELECT 'SRID=4;POINT(0 0)'::geometry;
			      geometry
	----------------------------------------------------
	 01010000200400000000000000000000000000000000000000
	(1 row)
	</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2523004"></a>4.2. Using OpenGIS Standards</h2></div></div><div></div></div><p>The OpenGIS "Simple Features Specification for SQL" defines
      standard GIS object types, the functions required to manipulate them,
      and a set of meta-data tables. In order to ensure that meta-data remain
      consistent, operations such as creating and removing a spatial column
      are carried out through special procedures defined by OpenGIS.</p><p>There are two OpenGIS meta-data tables:
      <tt class="varname">SPATIAL_REF_SYS</tt> and
      <tt class="varname">GEOMETRY_COLUMNS</tt>. The
      <tt class="varname">SPATIAL_REF_SYS</tt> table holds the numeric IDs and
      textual descriptions of coordinate systems used in the spatial
      database.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523037"></a>4.2.1. The SPATIAL_REF_SYS Table</h3></div></div><div></div></div><p>The <tt class="varname">SPATIAL_REF_SYS</tt> table definition is as
        follows:</p><pre class="programlisting">CREATE TABLE SPATIAL_REF_SYS ( 
  SRID INTEGER NOT NULL PRIMARY KEY, 
  AUTH_NAME VARCHAR(256), 
  AUTH_SRID INTEGER, 
  SRTEXT VARCHAR(2048), 
  PROJ4TEXT VARCHAR(2048)
)</pre><p>The <tt class="varname">SPATIAL_REF_SYS</tt> columns are as
        follows:</p><div class="variablelist"><dl><dt><span class="term">SRID</span></dt><dd><p>An integer value that uniquely identifies the Spatial
              Referencing System (SRS) within the database.</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>The name of the standard or standards body that is being
              cited for this reference system. For example, "EPSG" would be a
              valid <tt class="varname">AUTH_NAME</tt>.</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p>The ID of the Spatial Reference System as defined by the
              Authority cited in the <tt class="varname">AUTH_NAME</tt>. In the case
              of EPSG, this is where the EPSG projection code would go.</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>The Well-Known Text representation of the Spatial
              Reference System. An example of a WKT SRS representation
              is:</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N", 
  GEOGCS["NAD83",
    DATUM["North_American_Datum_1983", 
      SPHEROID["GRS 1980",6378137,298.257222101]
    ], 
    PRIMEM["Greenwich",0], 
    UNIT["degree",0.0174532925199433] 
  ],
  PROJECTION["Transverse_Mercator"], 
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123], 
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000], 
  PARAMETER["false_northing",0],
  UNIT["metre",1] 
]</pre><p>For a listing of EPSG projection codes and their
              corresponding WKT representations, see <a href="http://www.opengis.org/techno/interop/EPSG2WKT.TXT" target="_top">http://www.opengis.org/techno/interop/EPSG2WKT.TXT</a>.
              For a discussion of WKT in general, see the OpenGIS "Coordinate
              Transformation Services Implementation Specification" at <a href="http://www.opengis.org/techno/specs.htm" target="_top">http://www.opengis.org/techno/specs.htm</a>.
              For information on the European Petroleum Survey Group (EPSG)
              and their database of spatial reference systems, see <a href="http://epsg.org" target="_top">http://epsg.org</a>.</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGIS uses the Proj4 library to provide coordinate
              transformation capabilities. The <tt class="varname">PROJ4TEXT</tt>
              column contains the Proj4 coordinate definition string for a
              particular SRID. For example:</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>For more information about, see the Proj4 web site at
              <a href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>.
              The <tt class="filename">spatial_ref_sys.sql</tt> file contains both
              <tt class="varname">SRTEXT</tt> and <tt class="varname">PROJ4TEXT</tt>
              definitions for all EPSG projections.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523246"></a>4.2.2. The GEOMETRY_COLUMNS Table</h3></div></div><div></div></div><p>The <tt class="varname">GEOMETRY_COLUMNS</tt> table definition is as
        follows:</p><pre class="programlisting">CREATE TABLE GEOMETRY_COLUMNS ( 
  F_TABLE_CATALOG VARCHAR(256) NOT NULL, 
  F_TABLE_SCHEMA VARCHAR(256) NOT NULL, 
  F_TABLE_NAME VARCHAR(256) NOT NULL, 
  F_GEOMETRY_COLUMN VARCHAR(256) NOT NULL,
  COORD_DIMENSION INTEGER NOT NULL, 
  SRID INTEGER NOT NULL, 
  TYPE VARCHAR(30) NOT NULL 
)</pre><p>The columns are as follows:</p><div class="variablelist"><dl><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>The fully qualified name of the feature table containing
              the geometry column. Note that the terms "catalog" and "schema"
              are Oracle-ish. There is not PostgreSQL analogue of "catalog" so
              that column is left blank -- for "schema" the PostgreSQL schema
              name is used (<tt class="varname">public</tt> is the default).</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>The name of the geometry column in the feature
              table.</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>The spatial dimension (2, 3 or 4 dimensional) of the
              column.</p></dd><dt><span class="term">SRID</span></dt><dd><p>The ID of the spatial reference system used for the
              coordinate geometry in this table. It is a foreign key reference
              to the <tt class="varname">SPATIAL_REF_SYS</tt>.</p></dd><dt><span class="term">TYPE</span></dt><dd><p>The type of the spatial object. To restrict the spatial
              column to a single type, use one of: POINT, LINESTRING, POLYGON,
              MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION or
	      corresponding XYM versions POINTM, LINESTRINGM, POLYGONM,
	      MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM.
              For heterogeneous (mixed-type) collections, you can use
              "GEOMETRY" as the type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This attribute is (probably) not part of the OpenGIS
                specification, but is required for ensuring type
                homogeneity.</p></div></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523380"></a>4.2.3. Creating a Spatial Table</h3></div></div><div></div></div><p>Creating a table with spatial data is done in two stages:</p><div class="itemizedlist"><ul type="disc"><li><p>Create a normal non-spatial table.</p><p>For example: <span><b class="command">CREATE TABLE ROADS_GEOM ( ID int4,
            NAME varchar(25) )</b></span></p></li><li><p>Add a spatial column to the table using the OpenGIS
            "AddGeometryColumn" function.</p><p>The syntax is:
            </p><pre class="programlisting">AddGeometryColumn(&lt;schema_name&gt;, &lt;table_name&gt;,
            &lt;column_name&gt;, &lt;srid&gt;, &lt;type&gt;,
            &lt;dimension&gt;)</pre><p>

	    Or, using current schema:
            </p><pre class="programlisting">AddGeometryColumn(&lt;table_name&gt;,
            &lt;column_name&gt;, &lt;srid&gt;, &lt;type&gt;,
            &lt;dimension&gt;)</pre><p>
	    </p><p>Example1: <span><b class="command">SELECT AddGeometryColumn('public',
            'roads_geom', 'geom', 423, 'LINESTRING', 2)</b></span></p><p>Example2: <span><b class="command">SELECT AddGeometryColumn(
            'roads_geom', 'geom', 423, 'LINESTRING', 2)</b></span></p></li></ul></div><p>Here is an example of SQL used to create a table and add a
        spatial column (assuming that an SRID of 128
        exists already):</p><pre class="programlisting">CREATE TABLE parks ( PARK_ID int4, PARK_NAME varchar(128), PARK_DATE date, PARK_TYPE varchar(2) );
SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );</pre><p>Here is another example, using the generic "geometry" type and
        the undefined SRID value of -1:</p><pre class="programlisting">CREATE TABLE roads ( ROAD_ID int4, ROAD_NAME varchar(128) ); 
SELECT AddGeometryColumn( 'roads', 'roads_geom', -1, 'GEOMETRY', 3 );</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523486"></a>4.2.4. Ensuring OpenGIS compliancy of geometries</h3></div></div><div></div></div><p>Most of the functions implemented by the GEOS library
	rely on the assumption that your geometries are valid
        as specified by the OpenGIS Simple Feature Specification.
	To check validity of geometries you can use the
	<a href="ch06.html#IsValid">IsValid()</a> function:</p><pre class="programlisting">gisdb=# select isvalid('LINESTRING(0 0, 1 1)'), isvalid('LINESTRING(0 0,0 0)');
 isvalid | isvalid
---------+---------
 t       | f</pre><p>By default, PostGIS does not apply this validity check on geometry input, because
        testing for validity needs lots of CPU time for complex geometries, especially polygons.
        If you do not trust your data sources, you can manually enforce such a check to your tables
        by adding a check constraint:</p><pre class="programlisting">ALTER TABLE mytable ADD CONSTRAINT geometry_valid_check CHECK (isvalid(the_geom));</pre><p>If you encounter any strange error messages such as "GEOS Intersection() threw an 
        error!" or "JTS Intersection() threw an error!" when calling PostGIS functions with valid
        input geometries, you likely found an error in either PostGIS or one of the libraries it
        uses, and you should contact the PostGIS developers. The same is true if a PostGIS function returns
        an invalid geometry for valid input.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
	Strictly compliant OGC geometries cannot have Z or M values.
	The <a href="ch06.html#IsValid">IsValid()</a> function won't
	consider higher dimensioned geometries invalid! Invocations
	of <a href="ch06.html#AddGeometryColumn">AddGeometryColumn()</a>
        will add a constraint checking geometry dimensions, so it is
        enough to specify 2 there.
	</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2523576"></a>4.3. Loading GIS Data</h2></div></div><div></div></div><p>Once you have created a spatial table, you are ready to upload GIS
      data to the database. Currently, there are two ways to get data into a
      PostGIS/PostgreSQL database: using formatted SQL statements or using the
      Shape file loader/dumper.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523590"></a>4.3.1. Using SQL</h3></div></div><div></div></div><p>If you can convert your data to a text representation, then
        using formatted SQL might be the easiest way to get your data into
        PostGIS. As with Oracle and other SQL databases, data can be bulk
        loaded by piping a large text file full of SQL "INSERT" statements
        into the SQL terminal monitor.</p><p>A data upload file (<tt class="filename">roads.sql</tt> for example)
        might look like this:</p><pre class="programlisting">BEGIN;
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (1,GeomFromText('LINESTRING(191232 243118,191108 243242)',-1),'Jeff Rd'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (2,GeomFromText('LINESTRING(189141 244158,189265 244817)',-1),'Geordie Rd'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (3,GeomFromText('LINESTRING(192783 228138,192612 229814)',-1),'Paul St'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (4,GeomFromText('LINESTRING(189412 252431,189631 259122)',-1),'Graeme Ave'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (5,GeomFromText('LINESTRING(190131 224148,190871 228134)',-1),'Phil Tce'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (6,GeomFromText('LINESTRING(198231 263418,198213 268322)',-1),'Dave Cres');
COMMIT;</pre><p>The data file can be piped into PostgreSQL very easily using the
        "psql" SQL terminal monitor:</p><pre class="programlisting">psql -d [database] -f roads.sql</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523645"></a>4.3.2. Using the Loader</h3></div></div><div></div></div><p>The <tt class="filename">shp2pgsql</tt> data loader converts ESRI
        Shape files into SQL suitable for insertion into a PostGIS/PostgreSQL
        database. The loader has several operating modes distinguished by
        command line flags:</p><div class="variablelist"><dl><dt><span class="term">-d</span></dt><dd><p>Drops the database table before creating a new table with
              the data in the Shape file.</p></dd><dt><span class="term">-a</span></dt><dd><p>Appends data from the Shape file into the database table.
              Note that to use this option to load multiple files, the files
              must have the same attributes and same data types.</p></dd><dt><span class="term">-c</span></dt><dd><p>Creates a new table and populates it from the Shape file.
              <span class="emphasis"><em>This is the default mode.</em></span></p></dd><dt><span class="term">-p</span></dt><dd><p>Only produces the table creation SQL code, without adding 
              any actual data. This can be used if you need to completely
              separate the table creation and data loading steps.</p></dd><dt><span class="term">-D</span></dt><dd><p>Use the PostgreSQL "dump" format for the output data. This 
              can be combined with -a, -c and -d. It is much faster to load
              than the default "insert" SQL format. Use this for very large data
              sets.</p></dd><dt><span class="term">-s &lt;SRID&gt;</span></dt><dd><p>Creates and populates the geometry tables with the
              specified SRID.</p></dd><dt><span class="term">-k</span></dt><dd><p>Keep idendifiers case (column, schema and attributes). Note that attributes in Shapefile are all UPPERCASE.</p></dd><dt><span class="term">-i</span></dt><dd><p>Coerce all integers to standard 32-bit integers, do not
              create 64-bit bigints, even if the DBF header signature appears
              to warrant it.</p></dd><dt><span class="term">-I</span></dt><dd><p>Create a GiST index on the geometry column.</p></dd><dt><span class="term">-w</span></dt><dd><p>
       	      Output WKT format, for use with older (0.x) versions of PostGIS.
              Note  that this will introduce coordinate drifts and will drop M
              values from shapefiles.
              </p></dd><dt><span class="term">-W &lt;encoding&gt;</span></dt><dd><p>
Specify encoding of the input data (dbf file).
When used, all attributes of the dbf are converted from the specified
encoding to UTF8. The resulting SQL output will contain a <tt class="code">SET
CLIENT_ENCODING to UTF8</tt> command, so that the backend will be able
to reconvert from UTF8 to whatever encoding the database is configured
to use internally.
		</p></dd></dl></div><p>Note that -a, -c, -d and -p are mutually exclusive.</p><p>An example session using the loader to create an input file and
        uploading it might look like this:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable &gt; roads.sql 
# psql -d roadsdb -f roads.sql</pre><p>A conversion and upload can be done all in one step using UNIX
        pipes:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2523875"></a>4.4. Retrieving GIS Data</h2></div></div><div></div></div><p>Data can be extracted from the database using either SQL or the
      Shape file loader/dumper. In the section on SQL we will discuss some of
      the operators available to do comparisons and queries on spatial
      tables.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2523888"></a>4.4.1. Using SQL</h3></div></div><div></div></div><p>The most straightforward means of pulling data out of the
        database is to use a SQL select query and dump the resulting columns
        into a parsable text file:</p><pre class="programlisting">db=# SELECT id, AsText(geom) AS geom, name FROM ROADS_GEOM; 
id | geom                                    | name 
---+-----------------------------------------+-----------
 1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd  
 2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd 
 3 | LINESTRING(192783 228138,192612 229814) | Paul St 
 4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave 
 5 | LINESTRING(190131 224148,190871 228134) | Phil Tce 
 6 | LINESTRING(198231 263418,198213 268322) | Dave Cres 
 7 | LINESTRING(218421 284121,224123 241231) | Chris Way 
(6 rows)</pre><p>However, there will be times when some kind of restriction is
        necessary to cut down the number of fields returned. In the case of
        attribute-based restrictions, just use the same SQL syntax as normal
        with a non-spatial table. In the case of spatial restrictions, the
        following operators are available/useful:</p><div class="variablelist"><dl><dt><span class="term">&amp;&amp;</span></dt><dd><p>This operator tells whether the bounding box of one
              geometry intersects the bounding box of another.</p></dd><dt><span class="term">~=</span></dt><dd><p>This operators tests whether two geometries are
              geometrically identical. For example, if 'POLYGON((0 0,1 1,1 0,0
              0))' is the same as 'POLYGON((0 0,1 1,1 0,0 0))' (it is).</p></dd><dt><span class="term">=</span></dt><dd><p>This operator is a little more naive, it only tests
              whether the bounding boxes of to geometries are the same.</p></dd></dl></div><p>Next, you can use these operators in queries. Note that when
        specifying geometries and boxes on the SQL command line, you must
        explicitly turn the string representations into geometries by using
        the "GeomFromText()" function. So, for example:</p><pre class="programlisting">SELECT 
  ID, NAME 
FROM ROADS_GEOM 
WHERE 
  GEOM ~= GeomFromText('LINESTRING(191232 243118,191108 243242)',-1);</pre><p>The above query would return the single record from the
        "ROADS_GEOM" table in which the geometry was equal to that
        value.</p><p>When using the "&amp;&amp;" operator, you can specify either a
        BOX3D as the comparison feature or a GEOMETRY. When you specify a
        GEOMETRY, however, its bounding box will be used for the
        comparison.</p><pre class="programlisting">SELECT 
  ID, NAME 
FROM ROADS_GEOM 
WHERE 
  GEOM &amp;&amp; GeomFromText('POLYGON((191232 243117,191232 243119,191234 243117,191232 243117))',-1);</pre><p>The above query will use the bounding box of the polygon for
        comparison purposes.</p><p>The most common spatial query will probably be a "frame-based"
        query, used by client software, like data browsers and web mappers, to
        grab a "map frame" worth of data for display. Using a "BOX3D" object
        for the frame, such a query looks like this:</p><pre class="programlisting">SELECT 
  AsText(GEOM) AS GEOM 
FROM ROADS_GEOM 
WHERE 
  GEOM &amp;&amp; SetSRID('BOX3D(191232 243117,191232 243119)'::box3d,-1);</pre><p>Note the use of the SRID, to specify the projection of the
        BOX3D. The value -1 is used to indicate no specified SRID.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524054"></a>4.4.2. Using the Dumper</h3></div></div><div></div></div><p>The <tt class="filename">pgsql2shp</tt> table dumper connects
        directly to the database and converts a table (possibly defined by
	a query) into a shape file. The
        basic syntax is:</p><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;</pre><p>The commandline options are:</p><div class="variablelist"><dl><dt><span class="term">-f &lt;filename&gt;</span></dt><dd><p>Write the output to a particular filename.</p></dd><dt><span class="term">-h &lt;host&gt;</span></dt><dd><p>The database host to connect to.</p></dd><dt><span class="term">-p &lt;port&gt;</span></dt><dd><p>The port to connect to on the database host.</p></dd><dt><span class="term">-P &lt;password&gt;</span></dt><dd><p>The password to use when connecting to the
              database.</p></dd><dt><span class="term">-u &lt;user&gt;</span></dt><dd><p>The username to use when connecting to the
              database.</p></dd><dt><span class="term">-g &lt;geometry column&gt;</span></dt><dd><p>In the case of tables with multiple geometry columns, the
              geometry column to use when writing the shape file.</p></dd><dt><span class="term">-b</span></dt><dd><p>Use a binary cursor. This will make the operation faster,
	      but will not work if any NON-geometry attribute in the table
	      lacks a cast to text.</p></dd><dt><span class="term">-r</span></dt><dd><p>Raw mode. Do not drop the <tt class="varname">gid</tt> field, or
              escape column names.</p></dd><dt><span class="term">-d</span></dt><dd><p>For backward compatibility: write a 3-dimensional shape
	      file when dumping from old (pre-1.0.0) postgis databases (the
	      default is to write a 2-dimensional shape file in that case).
	      Starting from postgis-1.0.0+, dimensions are fully encoded.
	      </p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524232"></a>4.5. Building Indexes</h2></div></div><div></div></div><p>Indexes are what make using a spatial database for large data sets
      possible. Without indexing, any search for a feature would require a
      "sequential scan" of every record in the database. Indexing speeds up
      searching by organizing the data into a search tree which can be quickly
      traversed to find a particular record. PostgreSQL supports three kinds
      of indexes by default: B-Tree indexes, R-Tree indexes, and GiST
      indexes.</p><div class="itemizedlist"><ul type="disc"><li><p>B-Trees are used for data which can be sorted along one axis;
          for example, numbers, letters, dates. GIS data cannot be rationally
          sorted along one axis (which is greater, (0,0) or (0,1) or (1,0)?)
          so B-Tree indexing is of no use for us.</p></li><li><p>R-Trees break up data into rectangles, and sub-rectangles, and
          sub-sub rectangles, etc. R-Trees are used by some spatial databases
          to index GIS data, but the PostgreSQL R-Tree implementation is not
          as robust as the GiST implementation.</p></li><li><p>GiST (Generalized Search Trees) indexes break up data into
          "things to one side", "things which overlap", "things which are
          inside" and can be used on a wide range of data-types, including GIS
          data. PostGIS uses an R-Tree index implemented on top of GiST to
          index GIS data.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524285"></a>4.5.1. GiST Indexes</h3></div></div><div></div></div><p>GiST stands for "Generalized Search Tree" and is a generic form
        of indexing. In addition to GIS indexing, GiST is used to speed up
        searches on all kinds of irregular data structures (integer arrays,
        spectral data, etc) which are not amenable to normal B-Tree
        indexing.</p><p>Once a GIS data table exceeds a few thousand rows, you will want
        to build an index to speed up spatial searches of the data (unless all
        your searches are based on attributes, in which case you'll want to
        build a normal index on the attribute fields).</p><p>The syntax for building a GiST index on a "geometry" column is
        as follows:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] 
  USING GIST ( [geometryfield] GIST_GEOMETRY_OPS ); </pre><p>Building a spatial index is a computationally intensive
        exercise: on tables of around 1 million rows, on a 300MHz Solaris
        machine, we have found building a GiST index takes about 1 hour. After
        building an index, it is important to force PostgreSQL to collect
        table statistics, which are used to optimize query plans:</p><pre class="programlisting">VACUUM ANALYZE [table_name] [column_name];

-- This is only needed for PostgreSQL 7.4 installations and below
SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);</pre><p>GiST indexes have two advantages over R-Tree indexes in
        PostgreSQL. Firstly, GiST indexes are "null safe", meaning they can
        index columns which include null values. Secondly, GiST indexes
        support the concept of "lossiness" which is important when dealing
        with GIS objects larger than the PostgreSQL 8K page size. Lossiness
        allows PostgreSQL to store only the "important" part of an object in
        an index -- in the case of GIS objects, just the bounding box. GIS
        objects larger than 8K will cause R-Tree indexes to fail in the
        process of being built.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524354"></a>4.5.2. Using Indexes</h3></div></div><div></div></div><p>Ordinarily, indexes invisibly speed up data access: once the
        index is built, the query planner transparently decides when to use
        index information to speed up a query plan. Unfortunately, the
        PostgreSQL query planner does not optimize the use of GiST indexes
        well, so sometimes searches which should use a spatial index instead
        default to a sequence scan of the whole table.</p><p>If you find your spatial indexes are not being used (or your
        attribute indexes, for that matter) there are a couple things you can
        do:</p><div class="itemizedlist"><ul type="disc"><li><p>Firstly, make sure statistics are gathered about the number
            and distributions of values in a table, to provide the query
            planner with better information to make decisions around index
            usage. For PostgreSQL 7.4 installations and below this is done by
            running <span><b class="command">update_geometry_stats([table_name,
            column_name])</b></span> (compute distribution) and <span><b class="command">VACUUM
            ANALYZE [table_name] [column_name]</b></span> (compute number of
            values). Starting with PostgreSQL 8.0 running <span><b class="command">VACUUM
            ANALYZE</b></span> will do both operations. You should regularly
            vacuum your databases anyways -- many PostgreSQL DBAs have
            <span><b class="command">VACUUM</b></span> run as an off-peak cron job on a regular
            basis.</p></li><li><p>If vacuuming does not work, you can force the planner to use
            the index information by using the <span><b class="command">SET
            ENABLE_SEQSCAN=OFF</b></span> command. You should only use this
            command sparingly, and only on spatially indexed queries:
            generally speaking, the planner knows better than you do about
            when to use normal B-Tree indexes. Once you have run your query,
            you should consider setting <tt class="varname">ENABLE_SEQSCAN</tt> back
            on, so that other queries will utilize the planner as
            normal.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As of version 0.6, it should not be necessary to force the
              planner to use the index with
              <tt class="varname">ENABLE_SEQSCAN</tt>.</p></div></li><li><p>If you find the planner wrong about the cost of sequencial
            vs index scans try reducing the value of random_page_cost in
            postgresql.conf or using SET random_page_cost=#. Default value for
            the parameter is 4, try setting it to 1 or 2. Decrementing the
            value makes the planner more inclined of using Index scans.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524472"></a>4.6. Complex Queries</h2></div></div><div></div></div><p>The <span class="emphasis"><em>raison d'etre</em></span> of spatial database
      functionality is performing queries inside the database which would
      ordinarily require desktop GIS functionality. Using PostGIS effectively
      requires knowing what spatial functions are available, and ensuring that
      appropriate indexes are in place to provide good performance.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524491"></a>4.6.1. Taking Advantage of Indexes</h3></div></div><div></div></div><p>When constructing a query it is important to remember that only
        the bounding-box-based operators such as &amp;&amp; can take advatage
        of the GiST spatial index. Functions such as
        <tt class="varname">distance()</tt> cannot use the index to optimize their
        operation. For example, the following query would be quite slow on a
        large table:</p><pre class="programlisting">SELECT the_geom FROM geom_table
WHERE distance( the_geom, GeomFromText( 'POINT(100000 200000)', -1 ) ) &lt; 100</pre><p>This query is selecting all the geometries in geom_table which
        are within 100 units of the point (100000, 200000). It will be slow
        because it is calculating the distance between each point in the table
        and our specified point, ie. one <tt class="varname">distance()</tt>
        calculation for each row in the table. We can avoid this by using the
        &amp;&amp; operator to reduce the number of distance calculations
        required:</p><pre class="programlisting">SELECT the_geom FROM geom_table
WHERE the_geom &amp;&amp; 'BOX3D(90900 190900, 100100 200100)'::box3d
  AND distance( the_geom, GeomFromText( 'POINT(100000 200000)', -1 ) ) &lt; 100</pre><p>This query selects the same geometries, but it does it in a more
        efficient way. Assuming there is a GiST index on the_geom, the query
        planner will recognize that it can use the index to reduce the number
        of rows before calculating the result of the
        <tt class="varname">distance()</tt> function. Notice that the
        <tt class="varname">BOX3D</tt> geometry which is used in the &amp;&amp;
        operation is a 200 unit square box centered on the original point -
        this is our "query box". The &amp;&amp; operator uses the index to
        quickly reduce the result set down to only those geometries which have
        bounding boxes that overlap the "query box". Assuming that our query
        box is much smaller than the extents of the entire geometry table,
        this will drastically reduce the number of distance calculations that
        need to be done.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524587"></a>4.6.2. Examples of Spatial SQL</h3></div></div><div></div></div><p>The examples in this section will make use of two tables, a
        table of linear roads, and a table of polygonal municipality
        boundaries. The table definitions for the <tt class="varname">bc_roads</tt>
        table is:</p><pre class="programlisting">  Column    |       Type        |   Description
------------+-------------------+-------------------
 gid        | integer           | Unique ID
 name       | character varying | Road Name
 the_geom   | geometry          | Location Geometry (Linestring)</pre><p>The table definition for the <tt class="varname">bc_municipality</tt>
        table is:</p><pre class="programlisting">  Column   |       Type        |   Description
-----------+-------------------+-------------------
 gid       | integer           | Unique ID
 code      | integer           | Unique ID
 name      | character varying | City / Town Name
 the_geom  | geometry          | Location Geometry (Polygon)</pre><div class="qandaset"><dl><dt>4.6.2.1. <a href="ch04.html#id2524633">What is the total length of all roads, expressed in
                kilometers?</a></dt><dt>4.6.2.2. <a href="ch04.html#id2524660">How large is the city of Prince George, in
                hectares?</a></dt><dt>4.6.2.3. <a href="ch04.html#id2524689">What is the largest municipality in the province, by
                area?</a></dt><dt>4.6.2.4. <a href="ch04.html#id2524731">What is the length of roads fully contained within each
                municipality?</a></dt><dt>4.6.2.5. <a href="ch04.html#id2524793">Create a new table with all the roads within the city of
                Prince George.</a></dt><dt>4.6.2.6. <a href="ch04.html#id2524832">What is the length in kilometers of "Douglas St" in
                Victoria?</a></dt><dt>4.6.2.7. <a href="ch04.html#id2524866">What is the largest municipality polygon that has a
                hole?</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id2524633"></a><a name="id2524635"></a><b>4.6.2.1.</b></td><td align="left" valign="top"><p>What is the total length of all roads, expressed in
                kilometers?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>You can answer this question with a very simple piece of
                SQL:</p><pre class="programlisting">postgis=# SELECT sum(length(the_geom))/1000 AS km_roads FROM bc_roads;
     km_roads
------------------
 70842.1243039643
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524660"></a><a name="id2524663"></a><b>4.6.2.2.</b></td><td align="left" valign="top"><p>How large is the city of Prince George, in
                hectares?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>This query combines an attribute condition (on the
                municipality name) with a spatial calculation (of the
                area):</p><pre class="programlisting">postgis=# SELECT area(the_geom)/10000 AS hectares FROM bc_municipality 
          WHERE name = 'PRINCE GEORGE';
     hectares
------------------
 32657.9103824927
(1 row) </pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524689"></a><a name="id2524691"></a><b>4.6.2.3.</b></td><td align="left" valign="top"><p>What is the largest municipality in the province, by
                area?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>This query brings a spatial measurement into the query
                condition. There are several ways of approaching this problem,
                but the most efficient is below:</p><pre class="programlisting">postgis=# SELECT name, area(the_geom)/10000 AS hectares 
          FROM bc_municipality 
          ORDER BY hectares DESC 
          LIMIT 1;
     name      |    hectares
---------------+-----------------
 TUMBLER RIDGE | 155020.02556131
(1 row)</pre><p>Note that in order to answer this query we have to
                calculate the area of every polygon. If we were doing this a
                lot it would make sense to add an area column to the table
                that we could separately index for performance. By ordering
                the results in a descending direction, and them using the
                PostgreSQL "LIMIT" command we can easily pick off the largest
                value without using an aggregate function like max().</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524731"></a><a name="id2524733"></a><b>4.6.2.4.</b></td><td align="left" valign="top"><p>What is the length of roads fully contained within each
                municipality?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>This is an example of a "spatial join", because we are
                bringing together data from two tables (doing a join) but
                using a spatial interaction condition ("contained") as the
                join condition rather than the usual relational approach of
                joining on a common key:</p><pre class="programlisting">postgis=# SELECT m.name, sum(length(r.the_geom))/1000 as roads_km 
          FROM bc_roads AS r,bc_municipality AS m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND contains(m.the_geom,r.the_geom) 
          GROUP BY m.name 
          ORDER BY roads_km;

            name            |     roads_km
----------------------------+------------------
 SURREY                     | 1539.47553551242
 VANCOUVER                  | 1450.33093486576
 LANGLEY DISTRICT           | 833.793392535662
 BURNABY                    | 773.769091404338
 PRINCE GEORGE              |  694.37554369147
 ...</pre><p>This query takes a while, because every road in the
                table is summarized into the final result (about 250K roads
                for our particular example table). For smaller overlays
                (several thousand records on several hundred) the response can
                be very fast.</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524793"></a><a name="id2524795"></a><b>4.6.2.5.</b></td><td align="left" valign="top"><p>Create a new table with all the roads within the city of
                Prince George.</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>This is an example of an "overlay", which takes in two
                tables and outputs a new table that consists of spatially
                clipped or cut resultants. Unlike the "spatial join"
                demonstrated above, this query actually creates new
                geometries. An overlay is like a turbo-charged spatial join,
                and is useful for more exact analysis work:</p><pre class="programlisting">postgis=# CREATE TABLE pg_roads as
          SELECT intersection(r.the_geom, m.the_geom) AS intersection_geom, 
                 length(r.the_geom) AS rd_orig_length, 
                 r.* 
          FROM bc_roads AS r, bc_municipality AS m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND intersects(r.the_geom, m.the_geom) 
          AND m.name = 'PRINCE GEORGE';</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524832"></a><a name="id2524834"></a><b>4.6.2.6.</b></td><td align="left" valign="top"><p>What is the length in kilometers of "Douglas St" in
                Victoria?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><pre class="programlisting">postgis=# SELECT sum(length(r.the_geom))/1000 AS kilometers 
          FROM bc_roads r, bc_municipality m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND r.name = 'Douglas St' 
          AND m.name = 'VICTORIA';
    kilometers
------------------
 4.89151904172838
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2524866"></a><a name="id2524868"></a><b>4.6.2.7.</b></td><td align="left" valign="top"><p>What is the largest municipality polygon that has a
                hole?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><pre class="programlisting">postgis=# SELECT gid, name, area(the_geom) AS area 
          FROM bc_municipality 
          WHERE nrings(the_geom) &gt; 1 
          ORDER BY area DESC LIMIT 1;
 gid |     name     |       area
-----+--------------+------------------
  12 | SPALLUMCHEEN | 257374619.430216
(1 row)</pre></td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524902"></a>4.7. Using Mapserver</h2></div></div><div></div></div><p>The Minnesota Mapserver is an internet web-mapping server which
      conforms to the OpenGIS Web Mapping Server specification.</p><div class="itemizedlist"><ul type="disc"><li><p>The Mapserver homepage is at <a href="http://mapserver.gis.umn.edu" target="_top">http://mapserver.gis.umn.edu</a>.</p></li><li><p>The OpenGIS Web Map Specification is at <a href="http://www.opengis.org/techno/specs/01-047r2.pdf" target="_top">http://www.opengis.org/techno/specs/01-047r2.pdf</a>.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2524945"></a>4.7.1. Basic Usage</h3></div></div><div></div></div><p>To use PostGIS with Mapserver, you will need to know about how
        to configure Mapserver, which is beyond the scope of this
        documentation. This section will cover specific PostGIS issues and
        configuration details.</p><p>To use PostGIS with Mapserver, you will need:</p><div class="itemizedlist"><ul type="disc"><li><p>Version 0.6 or newer of PostGIS.</p></li><li><p>Version 3.5 or newer of Mapserver.</p></li></ul></div><p>Mapserver accesses PostGIS/PostgreSQL data like any other
        PostgreSQL client -- using <tt class="filename">libpq</tt>. This means that
        Mapserver can be installed on any machine with network access to the
        PostGIS server, as long as the system has the
        <tt class="filename">libpq</tt> PostgreSQL client libraries.</p><div class="orderedlist"><ol type="1"><li><p>Compile and install Mapserver, with whatever options you
            desire, including the "--with-postgis" configuration
            option.</p></li><li><p>In your Mapserver map file, add a PostGIS layer. For
            example:</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "widehighways"
  # Connect to a remote spatial database
  CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
  # Get the lines from the 'geom' column of the 'roads' table
  DATA "geom from roads"
  STATUS ON
  TYPE LINE
  # Of the lines in the extents, only render the wide highways
  FILTER "type = 'highway' and numlanes &gt;= 4"
  CLASS
    # Make the superhighways brighter and 2 pixels wide
    EXPRESSION ([numlanes] &gt;= 6)
    COLOR 255 22 22      
    SYMBOL "solid"
    SIZE 2
  END
  CLASS
    # All the rest are darker and only 1 pixel wide
    EXPRESSION ([numlanes] &lt; 6)
    COLOR 205 92 82      
  END
END</pre><p>In the example above, the PostGIS-specific directives are as
            follows:</p><div class="variablelist"><dl><dt><span class="term">CONNECTIONTYPE</span></dt><dd><p>For PostGIS layers, this is always "postgis".</p></dd><dt><span class="term">CONNECTION</span></dt><dd><p>The database connection is governed by the a
                  'connection string' which is a standard set of keys and
                  values like this (with the default values in
                  &lt;&gt;):</p><p>user=&lt;username&gt; password=&lt;password&gt;
                  dbname=&lt;username&gt; hostname=&lt;server&gt;
                  port=&lt;5432&gt;</p><p>An empty connection string is still valid, and any of
                  the key/value pairs can be omitted. At a minimum you will
                  generally supply the database name and username to connect
                  with.</p></dd><dt><span class="term">DATA</span></dt><dd><p>The form of this parameter is "&lt;column&gt; from
                  &lt;tablename&gt;" where the column is the spatial column to
                  be rendered to the map.</p></dd><dt><span class="term">FILTER</span></dt><dd><p>The filter must be a valid SQL string corresponding to
                  the logic normally following the "WHERE" keyword in a SQL
                  query. So, for example, to render only roads with 6 or more
                  lanes, use a filter of "num_lanes &gt;= 6".</p></dd></dl></div></li><li><p>In your spatial database, ensure you have spatial (GiST)
            indexes built for any the layers you will be drawing.</p><pre class="programlisting">CREATE INDEX [indexname]
  ON [tablename] 
  USING GIST ( [geometrycolumn] GIST_GEOMETRY_OPS );</pre></li><li><p>If you will be querying your layers using Mapserver you will
            also need an "oid index".</p><p>Mapserver requires unique identifiers for each spatial
            record when doing queries, and the PostGIS module of Mapserver
            uses the PostgreSQL <tt class="varname">oid</tt> value to provide these
            unique identifiers. A side-effect of this is that in order to do
            fast random access of records during queries, an index on the
            <tt class="varname">oid</tt> is needed.</p><p>To build an "oid index", use the following SQL:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] ( oid );</pre></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525193"></a>4.7.2. Frequently Asked Questions</h3></div></div><div></div></div><div class="qandaset"><dl><dt>4.7.2.1. <a href="ch04.html#id2525201">When I use an EXPRESSION in my map
                file, the condition never returns as true, even though I know
                the values exist in my table.</a></dt><dt>4.7.2.2. <a href="ch04.html#id2525235">The FILTER I use for my Shape files is not working for
                my PostGIS table of the same data.</a></dt><dt>4.7.2.3. <a href="ch04.html#id2525264">My PostGIS layer draws much slower than my Shape file
                layer, is this normal?</a></dt><dt>4.7.2.4. <a href="ch04.html#id2525302">My PostGIS layer draws fine, but queries are really
                slow. What is wrong?</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id2525201"></a><a name="id2525203"></a><b>4.7.2.1.</b></td><td align="left" valign="top"><p>When I use an <tt class="varname">EXPRESSION</tt> in my map
                file, the condition never returns as true, even though I know
                the values exist in my table.</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>Unlike shape files, PostGIS field names have to be
                referenced in EXPRESSIONS using <span class="emphasis"><em>lower
                case</em></span>.</p><pre class="programlisting">EXPRESSION ([numlanes] &gt;= 6)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2525235"></a><a name="id2525237"></a><b>4.7.2.2.</b></td><td align="left" valign="top"><p>The FILTER I use for my Shape files is not working for
                my PostGIS table of the same data.</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>Unlike shape files, filters for PostGIS layers use SQL
                syntax (they are appended to the SQL statement the PostGIS
                connector generates for drawing layers in Mapserver).</p><pre class="programlisting">FILTER "type = 'highway' and numlanes &gt;= 4"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2525264"></a><a name="id2525266"></a><b>4.7.2.3.</b></td><td align="left" valign="top"><p>My PostGIS layer draws much slower than my Shape file
                layer, is this normal?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>In general, expect PostGIS layers to be 10% slower than
                equivalent Shape files layers, due to the extra overhead
                involved in database connections, data transformations and
                data transit between the database and Mapserver.</p><p>If you are finding substantial draw performance
                problems, it is likely that you have not build a spatial index
                on your table.</p><pre class="programlisting">postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn );
postgis# SELECT update_geometry_stats();  -- For PGSQL &lt; 8.0
postgis# VACUUM ANALYZE;                  -- For PGSQL &gt;= 8.0</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2525302"></a><a name="id2525304"></a><b>4.7.2.4.</b></td><td align="left" valign="top"><p>My PostGIS layer draws fine, but queries are really
                slow. What is wrong?</p></td></tr><tr class="answer"><td align="left" valign="top"><b></b></td><td align="left" valign="top"><p>For queries to be fast, you must have a unique key for
                your spatial table and you must have an index on that unique
                key.</p><p>You can specify what unique key for mapserver to use
                with the <tt class="varname">USING UNIQUE</tt> clause in your
                <tt class="varname">DATA</tt> line:</p><pre class="programlisting">DATA "the_geom FROM geotable USING UNIQUE gid"</pre><p>If your table does not have an explicit unique column,
                you can "fake" a unique column by using the PostgreSQL row
                "oid" for your unique column. "oid" is the default unique
                column if you do not declare one, so enhancing your query
                speed is a matter of building an index on your spatial table
                oid value.</p><pre class="programlisting">postgis# CREATE INDEX geotable_oid_idx ON geotable (oid);</pre></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525360"></a>4.7.3. Advanced Usage</h3></div></div><div></div></div><p>The <tt class="varname">USING</tt> pseudo-SQL clause is used to add
        some information to help mapserver understand the results of more
        complex queries. More specifically, when either a view or a subselect
        is used as the source table (the thing to the right of "FROM" in a
        <tt class="varname">DATA</tt> definition) it is more difficult for mapserver
        to automatically determine a unique identifier for each row and also
        the SRID for the table. The <tt class="varname">USING</tt> clause can
        provide mapserver with these two pieces of information as
        follows:</p><pre class="programlisting">DATA "the_geom FROM (SELECT table1.the_geom AS the_geom, table1.oid AS oid, table2.data AS data
 FROM table1 LEFT JOIN table2 ON table1.id = table2.id) AS new_table USING UNIQUE oid USING SRID=-1"</pre><div class="variablelist"><dl><dt><span class="term">USING UNIQUE &lt;uniqueid&gt;</span></dt><dd><p>Mapserver requires a unique id for each row in order to
              identify the row when doing map queries. Normally, it would use
              the oid as the unique identifier, but views and subselects don't
              automatically have an oid column. If you want to use Mapserver's
              query functionality, you need to add a unique column to your
              view or subselect, and declare it with <tt class="varname">USING
              UNIQUE</tt>. For example, you could explicitly select one
              of the table's oid values for this purpose, or any other column
              which is guaranteed to be unique for the result set.</p><p>The <tt class="varname">USING</tt> statement can also be useful
              even for simple <tt class="varname">DATA</tt> statements, if you are
              doing map queries. It was previously recommended to add an index
              on the oid column of tables used in query-able layers, in order
              to speed up the performance of map queries. However, with the
              <tt class="varname">USING</tt> clause, it is possible to tell
              mapserver to use your table's primary key as the identifier for
              map queries, and then it is no longer necessary to have an
              additional index.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>"Querying a Map" is the action of clicking on a map to
                ask for information about the map features in that location.
                Don't confuse "map queries" with the SQL query in a
                <tt class="varname">DATA</tt> definition.</p></div></dd><dt><span class="term">USING SRID=&lt;srid&gt;</span></dt><dd><p>PostGIS needs to know which spatial referencing system is
              being used by the geometries in order to return the correct data
              back to mapserver. Normally it is possible to find this
              information in the "geometry_columns" table in the PostGIS
              database, however, this is not possible for tables which are
              created on the fly such as subselects and views. So the
              <tt class="varname">USING SRID=</tt> option allows the correct SRID to
              be specified in the <tt class="varname">DATA</tt> definition.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>The parser for Mapserver PostGIS layers is fairly primitive,
          and is case sensitive in a few areas. Be careful to ensure that all
          SQL keywords and all your <tt class="varname">USING</tt> clauses are in
          upper case, and that your <tt class="varname">USING UNIQUE</tt> clause
          precedes your <tt class="varname">USING SRID</tt> clause.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2453149"></a>4.7.4. Examples</h3></div></div><div></div></div><p>Lets start with a simple example and work our way up. Consider
        the following Mapserver layer definition:</p><pre class="programlisting">LAYER
 CONNECTIONTYPE postgis
 NAME "roads"
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 STATUS ON
 TYPE LINE
 CLASS
  COLOR 0 0 0
 END
END</pre><p>This layer will display all the road geometries in the roads
        table as black lines.</p><p>Now lets say we want to show only the highways until we get
        zoomed in to at least a 1:100000 scale - the next two layers will
        acheive this effect:</p><pre class="programlisting">LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 MINSCALE 100000
 STATUS ON
 TYPE LINE
 FILTER "road_type = 'highway'"
 CLASS
  COLOR 0 0 0
 END
END

LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 MAXSCALE 100000
 STATUS ON
 TYPE LINE
 CLASSITEM road_type
 CLASS
  EXPRESSION "highway"
  SIZE 2
  COLOR 255 0 0
 END
 CLASS
  COLOR 0 0 0
 END
END</pre><p>The first layer is used when the scale is greater than 1:100000,
        and displays only the roads of type "highway" as black lines. The
        <tt class="varname">FILTER</tt> option causes only roads of type "highway"
        to be displayed.</p><p>The second layer is used when the scale is less than 1:100000,
        and will display highways as double-thick red lines, and other roads
        as regular black lines.</p><p>So, we have done a couple of interesting things using only
        mapserver functionality, but our <tt class="varname">DATA</tt> SQL statement
        has remained simple. Suppose that the name of the road is stored in
        another table (for whatever reason) and we need to do a join to get it
        and label our roads.</p><pre class="programlisting">LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM (SELECT roads.oid AS oid, roads.the_geom AS the_geom, road_names.name as name
   FROM roads LEFT JOIN road_names ON roads.road_name_id = road_names.road_name_id) AS named_roads
   USING UNIQUE oid USING SRID=-1"
 MAXSCALE 20000
 STATUS ON
 TYPE ANNOTATION
 LABELITEM name
 CLASS
  LABEL
   ANGLE auto
   SIZE 8
   COLOR 0 192 0
   TYPE truetype
   FONT arial
  END
 END
END</pre><p>This annotation layer adds green labels to all the roads when
        the scale gets down to 1:20000 or less. It also demonstrates how to
        use an SQL join in a <tt class="varname">DATA</tt> definition.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2453247"></a>4.8. Java Clients (JDBC)</h2></div></div><div></div></div><p>Java clients can access PostGIS "geometry" objects in the
      PostgreSQL database either directly as text representations or using the
      JDBC extension objects bundled with PostGIS. In order to use the
      extension objects, the "postgis.jar" file must be in your CLASSPATH
      along with the "postgresql.jar" JDBC driver package.</p><pre class="programlisting">import java.sql.*; 
import java.util.*; 
import java.lang.*; 
import org.postgis.*; 

public class JavaGIS { 
  public static void main(String[] args) 
  { 
    java.sql.Connection conn; 
    try 
    { 
      /* 
      * Load the JDBC driver and establish a connection. 
      */  
      Class.forName("org.postgresql.Driver"); 
      String url = "jdbc:postgresql://localhost:5432/database"; 
      conn = DriverManager.getConnection(url, "postgres", ""); 
    
      /* 
      * Add the geometry types to the connection. Note that you 
      * must cast the connection to the pgsql-specific connection * implementation before calling the addDataType() method. 
      */
      ((org.postgresql.Connection)conn).addDataType("geometry","org.postgis.PGgeometry");
      ((org.postgresql.Connection)conn).addDataType("box3d","org.postgis.PGbox3d");

      /* 
      * Create a statement and execute a select query. 
      */ 
      Statement s = conn.createStatement(); 
      ResultSet r = s.executeQuery("select AsText(geom) as geom,id from geomtable"); 
      while( r.next() ) 
      { 
        /* 
        * Retrieve the geometry as an object then cast it to the geometry type. 
        * Print things out. 
        */ 
        PGgeometry geom = (PGgeometry)r.getObject(1); 
        int id = r.getInt(2);
        System.out.println("Row " + id + ":"); 
        System.out.println(geom.toString()); 
      }
      s.close(); 
      conn.close(); 
    } 
    catch( Exception e ) 
    { 
      e.printStackTrace(); 
    }  
  }
}</pre><p>The "PGgeometry" object is a wrapper object which contains a
      specific topological geometry object (subclasses of the abstract class
      "Geometry") depending on the type: Point, LineString, Polygon,
      MultiPoint, MultiLineString, MultiPolygon.</p><pre class="programlisting">PGgeometry geom = (PGgeometry)r.getObject(1); 
if( geom.getType() = Geometry.POLYGON ) 
{ 
  Polygon pl = (Polygon)geom.getGeometry();
  for( int r = 0; r &lt; pl.numRings(); r++ ) 
  { 
    LinearRing rng = pl.getRing(r);
    System.out.println("Ring: " + r); 
    for( int p = 0; p &lt; rng.numPoints(); p++ ) 
    { 
      Point pt = rng.getPoint(p); 
      System.out.println("Point: " + p);
      System.out.println(pt.toString()); 
    } 
  } 
}</pre><p>The JavaDoc for the extension objects provides a reference for the
      various data accessor functions in the geometric objects.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2525835"></a>4.9. C Clients (libpq)</h2></div></div><div></div></div><p>...</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525844"></a>4.9.1. Text Cursors</h3></div></div><div></div></div><p>...</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2525854"></a>4.9.2. Binary Cursors</h3></div></div><div></div></div><p>...</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Frequently Asked Questions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Performance tips</td></tr></table></div></body></html>
